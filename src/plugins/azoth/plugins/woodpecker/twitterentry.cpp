
/**********************************************************************
 * LeechCraft - modular cross-platform feature rich internet client.
 * Copyright (C) 2006-2013  Slava Barinov
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **********************************************************************/

#include "twitterentry.h"
#include <QStringList>
#include <QtDebug>
#include <QTimer>
#include <util/util.h>
#include <interfaces/azoth/azothutil.h>
#include "xmlsettingsmanager.h"
#include "twitteraccount.h"
#include "twittermessage.h"

namespace LeechCraft
{
namespace Azoth
{
namespace Woodpecker
{
	TwitterEntry::TwitterEntry (const UserInfo& info, const TwitterUser *const user, TwitterAccount *account)
	: QObject (account)
	, Account_ (account)
	, User_ (user)
	, Info_ (info)
	, Avatar_ (user->GetAvatar ().toImage ())
	{
		for (const auto& id : info.Lists_)
		{
			const auto& info = account->GetListInfo (id);
			if (info.ID_ == id)
				Groups_ << info.Name_;
		}

		XmlSettingsManager::Instance ()
				->RegisterObject ("EntryNameFormat", this, "handleEntryNameFormat");
	}

	const UserInfo& TwitterEntry::GetInfo () const
	{
		return Info_;
	}

	void TwitterEntry::Send (TwitterMessage *msg)
	{
		Account_->Send (this, msg);
	}

	void TwitterEntry::Store (TwitterMessage *msg)
	{
		Messages_ << msg;
		emit gotMessage (msg);
	}

	void TwitterEntry::HandleMessage (MessageInfo info)
	{
		if (info.Flags_ & MessageFlag::Outbox)
		{
			for (int i = Messages_.size () - 1; i >= 0; --i)
			{
				auto msg = Messages_.at (i);
				if (msg->GetID () == static_cast<qulonglong> (-1) &&
				    msg->GetDirection () == IMessage::Direction::Out &&
						msg->GetBody () == info.Text_)
					return;
			}
		}

		const auto dir = info.Flags_ & MessageFlag::Outbox ?
		  IMessage::Direction::Out :
		  IMessage::Direction::In;

		if (dir == IMessage::Direction::In)
		{
			emit chatPartStateChanged (CPSActive, "");
			HasUnread_ = true;
		}

		auto msg = new TwitterMessage (dir, IMessage::Type::ChatMessage, this);
		msg->SetBody (info.Text_);
		msg->SetDateTime (info.TS_);
		msg->SetID (info.ID_);

		Store (msg);
	}

	QObject* TwitterEntry::GetQObject ()
	{
		return this;
	}

	IAccount* TwitterEntry::GetParentAccount () const
	{
		return Account_;
	}

	ICLEntry::Features TwitterEntry::GetEntryFeatures () const
	{
		return FPermanentEntry | FHasCustomChatWidget;
	}

	ICLEntry::EntryType TwitterEntry::GetEntryType () const
	{
		return ICLEntry::EntryType::Chat;
	}

	QString TwitterEntry::GetEntryName () const
	{
		auto string = XmlSettingsManager::Instance ()->property ("EntryNameFormat").toString ();
		string.replace ("$name", Info_.FirstName_);
		string.replace ("$surname", Info_.LastName_);
		string.replace ("$nick", Info_.Nick_);
		string.replace ("  ", " ");
		return string;
	}

	void TwitterEntry::SetEntryName (const QString&)
	{
	}

	QString TwitterEntry::GetEntryID () const
	{
		return Account_->GetAccountID () + QString::number (Info_.ID_);
	}

	QString TwitterEntry::GetHumanReadableID () const
	{
		return QString::number (Info_.ID_);
	}

	QStringList TwitterEntry::Groups () const
	{
		return Groups_;
	}

	void TwitterEntry::SetGroups (const QStringList& groups)
	{
	}

	QStringList TwitterEntry::Variants () const
	{
		return Info_.IsOnline_ ? QStringList ("") : QStringList ();
	}

	IMessage* TwitterEntry::CreateMessage (IMessage::Type type, const QString& variant, const QString& body)
	{
	    auto msg = new TwitterMessage (IMessage::Direction::Out, type, this);
		msg->SetBody (body);
		return msg;
	}

	QList<IMessage*> TwitterEntry::GetAllMessages () const
	{
		QList<IMessage*> result;
		for (auto obj : Messages_)
			result << obj;
		return result;
	}

	void TwitterEntry::PurgeMessages (const QDateTime& before)
	{
		AzothUtil::StandardPurgeMessages (Messages_, before);
	}

	void TwitterEntry::SetChatPartState (ChatPartState state, const QString& variant)
	{
	}

	EntryStatus TwitterEntry::GetStatus (const QString&) const
	{
		return { Info_.IsOnline_ ? SOnline : SOffline, {} };
	}

	QImage TwitterEntry::GetAvatar () const
	{
		return Avatar_;
	}

	QString TwitterEntry::GetRawInfo () const
	{
		return {};
	}

	void TwitterEntry::ShowInfo ()
	{
		return;
	}

	QList<QAction*> TwitterEntry::GetActions () const
	{
		return {};
	}

	QMap<QString, QVariant> TwitterEntry::GetClientInfo (const QString&) const
	{
		return {};
	}

	void TwitterEntry::MarkMsgsRead ()
	{
		if (!HasUnread_)
			return;

		QList<qulonglong> ids;
		for (auto msg : Messages_)
			if (!msg->IsRead ())
			{
				ids << msg->GetID ();
				msg->SetRead ();
			}

		HasUnread_ = false;
	}

	void TwitterEntry::ChatTabClosed ()
	{
	}

	void TwitterEntry::handleEntryNameFormat ()
	{
		emit nameChanged (GetEntryName ());
	}
}
}
}
